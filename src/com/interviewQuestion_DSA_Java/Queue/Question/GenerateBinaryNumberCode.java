package com.interviewQuestion_DSA_Java.Queue.Question;

import java.util.LinkedList;
import java.util.Queue;

public class GenerateBinaryNumberCode {

    // Function to generate and print binary numbers from 1 to N
    public static void generateBinaryNumbers(int N) {
        Queue<String> queue = new LinkedList<>();
        queue.add("1");

        // Loop until we generate all binary numbers up to N
        for (int i = 1; i <= N; i++) {
            String binary = queue.poll(); // Get the front of the queue
            System.out.print(binary + " "); // Print the binary number

            // Generate next two binary numbers and add them to the queue
            queue.add(binary + "0");
            queue.add(binary + "1");
        }
    }

    public static void main(String[] args) {
        int N = 5; // Example input
        generateBinaryNumbers(N);
    }
}
/*âœ… Letâ€™s do a Deep Dry Run of the code step by step to understand how the Generate Binary Number Code works.

ðŸ“š Problem Statement:
You are required to generate and print binary numbers from 1 to N using a queue.

ðŸ“ Input:
java
Copy
Edit
int N = 5;
ðŸ”¥ Goal:
Generate binary numbers:

Copy
Edit
1 10 11 100 101
ðŸŽ¯ Approach Overview:
Queue Usage:

We use a queue to generate the binary numbers sequentially.

Each time we dequeue a number, we generate the next two binary numbers by appending 0 and 1 to it.

Logic:

Start by adding "1" to the queue.

Dequeue the front element, print it, and generate the next binary numbers by adding:

binary + "0"

binary + "1"

âœ… Step 1: Create and Initialize Queue
java
Copy
Edit
Queue<String> queue = new LinkedList<>();
queue.add("1");  // Add the first binary number "1" to the queue
ðŸ“Œ Queue after initialization:
vbnet
Copy
Edit
Queue: ["1"]
âœ… Step 2: Start Loop to Generate Binary Numbers
java
Copy
Edit
for (int i = 1; i <= N; i++) {
    String binary = queue.poll(); // Get the front of the queue
    System.out.print(binary + " "); // Print the binary number

    // Generate next two binary numbers
    queue.add(binary + "0");
    queue.add(binary + "1");
}
ðŸ”¥ Dry Run:
ðŸŽ‰ Initial Setup:
makefile
Copy
Edit
N = 5
Queue: ["1"]
ðŸ” Iteration 1: i = 1
binary = queue.poll() â†’ Dequeue "1"

Print: 1

Add next binaries:

"10" â†’ Add binary + "0"

"11" â†’ Add binary + "1"

ðŸ“Œ Queue after Iteration 1:
vbnet
Copy
Edit
Queue: ["10", "11"]
ðŸ” Iteration 2: i = 2
binary = queue.poll() â†’ Dequeue "10"

Print: 10

Add next binaries:

"100" â†’ Add binary + "0"

"101" â†’ Add binary + "1"

ðŸ“Œ Queue after Iteration 2:
vbnet
Copy
Edit
Queue: ["11", "100", "101"]
ðŸ” Iteration 3: i = 3
binary = queue.poll() â†’ Dequeue "11"

Print: 11

Add next binaries:

"110" â†’ Add binary + "0"

"111" â†’ Add binary + "1"

ðŸ“Œ Queue after Iteration 3:
vbnet
Copy
Edit
Queue: ["100", "101", "110", "111"]
ðŸ” Iteration 4: i = 4
binary = queue.poll() â†’ Dequeue "100"

Print: 100

Add next binaries:

"1000" â†’ Add binary + "0"

"1001" â†’ Add binary + "1"

ðŸ“Œ Queue after Iteration 4:
vbnet
Copy
Edit
Queue: ["101", "110", "111", "1000", "1001"]
ðŸ” Iteration 5: i = 5
binary = queue.poll() â†’ Dequeue "101"

Print: 101

Add next binaries:

"1010" â†’ Add binary + "0"

"1011" â†’ Add binary + "1"

ðŸ“Œ Queue after Iteration 5:
vbnet
Copy
Edit
Queue: ["110", "111", "1000", "1001", "1010", "1011"]
âœ… We have generated 5 binary numbers, so the loop ends here.

ðŸ”¥ Step 3: Print the Result
ðŸ“ Final Output:
Copy
Edit
1 10 11 100 101
âš¡ï¸ Final Queue State:
vbnet
Copy
Edit
Queue: ["110", "111", "1000", "1001", "1010", "1011"]
ðŸ“Š Time Complexity Analysis:
Generating N Binary Numbers:

For every binary number generated, 2 more numbers are added to the queue.

Each operation of enqueue and dequeue takes O(1).

Overall Time Complexity:

O(N)
O(N)
ðŸ’¾ Space Complexity Analysis:
Space for Queue:

The queue stores at most 2N binary numbers.

Overall Space Complexity:

O(N)
O(N)
ðŸ“ Summary of Key Points:
âœ… The algorithm efficiently generates binary numbers from 1 to N using a queue.
âœ… Binary numbers are generated by appending 0 and 1 to the front element dequeued from the queue.
âœ… Final output for N = 5 is:

Copy
Edit
1 10 11 100 101
Let me know if you want to practice more DSA problems like this! ðŸ˜Š*/